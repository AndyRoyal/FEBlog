## 变量、作用域和内存问题
### 前言
按照ECMA-262的定义，JavaScript的变量与其他语言的变量有很大区别。JavaScript变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。  

### 1、基本类型值和引用类型值  
在将一个值赋值给变量时，解析器必须确定这个值是基本类型值还是引用类型值。  
Undefined、Null、Boolean、Number、String、Symbol和BigInt。这7种基本类型是按值访问的，因为可以操作保存在变量中的实际的值。  

引用类型值是保存在堆内存的对象。JavaScript不允许直接访问堆内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。  

1.1、传递参数  
ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数。就和把值从一个变量复制到另一个变量一样。  

在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念就是arguments对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。  

### 2、执行环境及作用域
执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象。环境中定义的所有变量和函数都保存在这个对象中。  

* 全局执行环境。  
根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境知道应用程序退出--例如关闭浏览器或页面--时才会被销毁）  

* 函数执行环境。  
当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回之前的执行环境。ECMAScript程序中的执行流正式由这个方便的机制控制着。  

* 作用域链。  
当代吗在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终是当前执行的代码所在的环境的变脸对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始只包含一个变量，即arguments对象。作用域链中的下一个变量对象来自包含（外部）环境，而在下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境。  

* 基本包装类型  
为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型：Boolean、Number和String。  
举例：  
var s1 = 'some text'
var s2 = s1.substring(2)  

这个例子中的变量s1包含了一个字符串，字符串当然是基本类型值。下一行调用了s1的substring()方法，并将返回值保存在了s2中。但基本类型值不是对象，因此从逻辑上讲它们不应该有方法。其实，为了实现这种直观的操作，后台已经完成了一系列的处理。当第二行代码访问s1时，访问过程处于一种读取的模式，也就是要从内容中读取这个字符串的值。而读取模式中访问字符串时，后台都会自动完成下列处理：  
1、创建String类型的一个实例；  
2、在实例上调用制定的方法；  
3、销毁这个实例；  

可以将以上三个步骤想象成是执行了下列ECMAScript代码。  
```
var s1 = new String('some text');
var s2 = s1.substring(2);
s1 = null
```
经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于Boolean和Number类型对应的布尔值和数字值。  

引用类型和基本包装类型的区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在与一行代码的执行瞬间，然后立即被销毁。这意味着，我们不能在运行时为基本类型值添加属性和方法。  

### Global
部署图任何其他对象的属性和方法，最终都是Global对象的属性。  

1、URI编码方法  
Global对象的encodeURI（）和encodeURIComponent（）方法可以对URI进行编码。有效的URI中不能包含某些字符，例如空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。  

其中，encodeURI主要用于整个URI，而encodeURIComponent（）主要用于对URI中的某一段进行编码。主要区别在于，encodeURI（）不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井号；而encodeURIComponent（）则会对它发现的任何非便准字符进行编码。   

与encodeURI（）和encodeURIComponent（）方法对应的两个方法分别是decodeURI（）和decodeURIComponent（）。